{"code":"var vendor_a322e965b091506e15bb=function(e){var n={};function r(t){if(n[t])return n[t].exports;var o=n[t]={i:t,l:!1,exports:{}};return e[t].call(o.exports,o,o.exports,r),o.l=!0,o.exports}return r.m=e,r.c=n,r.d=function(e,n,t){r.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:t})},r.r=function(e){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(e,\"__esModule\",{value:!0})},r.t=function(e,n){if(1&n&&(e=r(e)),8&n)return e;if(4&n&&\"object\"==typeof e&&e&&e.__esModule)return e;var t=Object.create(null);if(r.r(t),Object.defineProperty(t,\"default\",{enumerable:!0,value:e}),2&n&&\"string\"!=typeof e)for(var o in e)r.d(t,o,function(n){return e[n]}.bind(null,o));return t},r.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(n,\"a\",n),n},r.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},r.p=\"dist/\",r(r.s=3)}([function(module,exports){eval(\"(function(self) {\\n  'use strict';\\n\\n  if (self.fetch) {\\n    return\\n  }\\n\\n  var support = {\\n    searchParams: 'URLSearchParams' in self,\\n    iterable: 'Symbol' in self && 'iterator' in Symbol,\\n    blob: 'FileReader' in self && 'Blob' in self && (function() {\\n      try {\\n        new Blob()\\n        return true\\n      } catch(e) {\\n        return false\\n      }\\n    })(),\\n    formData: 'FormData' in self,\\n    arrayBuffer: 'ArrayBuffer' in self\\n  }\\n\\n  if (support.arrayBuffer) {\\n    var viewClasses = [\\n      '[object Int8Array]',\\n      '[object Uint8Array]',\\n      '[object Uint8ClampedArray]',\\n      '[object Int16Array]',\\n      '[object Uint16Array]',\\n      '[object Int32Array]',\\n      '[object Uint32Array]',\\n      '[object Float32Array]',\\n      '[object Float64Array]'\\n    ]\\n\\n    var isDataView = function(obj) {\\n      return obj && DataView.prototype.isPrototypeOf(obj)\\n    }\\n\\n    var isArrayBufferView = ArrayBuffer.isView || function(obj) {\\n      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\\n    }\\n  }\\n\\n  function normalizeName(name) {\\n    if (typeof name !== 'string') {\\n      name = String(name)\\n    }\\n    if (/[^a-z0-9\\\\-#$%&'*+.\\\\^_`|~]/i.test(name)) {\\n      throw new TypeError('Invalid character in header field name')\\n    }\\n    return name.toLowerCase()\\n  }\\n\\n  function normalizeValue(value) {\\n    if (typeof value !== 'string') {\\n      value = String(value)\\n    }\\n    return value\\n  }\\n\\n  // Build a destructive iterator for the value list\\n  function iteratorFor(items) {\\n    var iterator = {\\n      next: function() {\\n        var value = items.shift()\\n        return {done: value === undefined, value: value}\\n      }\\n    }\\n\\n    if (support.iterable) {\\n      iterator[Symbol.iterator] = function() {\\n        return iterator\\n      }\\n    }\\n\\n    return iterator\\n  }\\n\\n  function Headers(headers) {\\n    this.map = {}\\n\\n    if (headers instanceof Headers) {\\n      headers.forEach(function(value, name) {\\n        this.append(name, value)\\n      }, this)\\n    } else if (Array.isArray(headers)) {\\n      headers.forEach(function(header) {\\n        this.append(header[0], header[1])\\n      }, this)\\n    } else if (headers) {\\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\\n        this.append(name, headers[name])\\n      }, this)\\n    }\\n  }\\n\\n  Headers.prototype.append = function(name, value) {\\n    name = normalizeName(name)\\n    value = normalizeValue(value)\\n    var oldValue = this.map[name]\\n    this.map[name] = oldValue ? oldValue+','+value : value\\n  }\\n\\n  Headers.prototype['delete'] = function(name) {\\n    delete this.map[normalizeName(name)]\\n  }\\n\\n  Headers.prototype.get = function(name) {\\n    name = normalizeName(name)\\n    return this.has(name) ? this.map[name] : null\\n  }\\n\\n  Headers.prototype.has = function(name) {\\n    return this.map.hasOwnProperty(normalizeName(name))\\n  }\\n\\n  Headers.prototype.set = function(name, value) {\\n    this.map[normalizeName(name)] = normalizeValue(value)\\n  }\\n\\n  Headers.prototype.forEach = function(callback, thisArg) {\\n    for (var name in this.map) {\\n      if (this.map.hasOwnProperty(name)) {\\n        callback.call(thisArg, this.map[name], name, this)\\n      }\\n    }\\n  }\\n\\n  Headers.prototype.keys = function() {\\n    var items = []\\n    this.forEach(function(value, name) { items.push(name) })\\n    return iteratorFor(items)\\n  }\\n\\n  Headers.prototype.values = function() {\\n    var items = []\\n    this.forEach(function(value) { items.push(value) })\\n    return iteratorFor(items)\\n  }\\n\\n  Headers.prototype.entries = function() {\\n    var items = []\\n    this.forEach(function(value, name) { items.push([name, value]) })\\n    return iteratorFor(items)\\n  }\\n\\n  if (support.iterable) {\\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries\\n  }\\n\\n  function consumed(body) {\\n    if (body.bodyUsed) {\\n      return Promise.reject(new TypeError('Already read'))\\n    }\\n    body.bodyUsed = true\\n  }\\n\\n  function fileReaderReady(reader) {\\n    return new Promise(function(resolve, reject) {\\n      reader.onload = function() {\\n        resolve(reader.result)\\n      }\\n      reader.onerror = function() {\\n        reject(reader.error)\\n      }\\n    })\\n  }\\n\\n  function readBlobAsArrayBuffer(blob) {\\n    var reader = new FileReader()\\n    var promise = fileReaderReady(reader)\\n    reader.readAsArrayBuffer(blob)\\n    return promise\\n  }\\n\\n  function readBlobAsText(blob) {\\n    var reader = new FileReader()\\n    var promise = fileReaderReady(reader)\\n    reader.readAsText(blob)\\n    return promise\\n  }\\n\\n  function readArrayBufferAsText(buf) {\\n    var view = new Uint8Array(buf)\\n    var chars = new Array(view.length)\\n\\n    for (var i = 0; i < view.length; i++) {\\n      chars[i] = String.fromCharCode(view[i])\\n    }\\n    return chars.join('')\\n  }\\n\\n  function bufferClone(buf) {\\n    if (buf.slice) {\\n      return buf.slice(0)\\n    } else {\\n      var view = new Uint8Array(buf.byteLength)\\n      view.set(new Uint8Array(buf))\\n      return view.buffer\\n    }\\n  }\\n\\n  function Body() {\\n    this.bodyUsed = false\\n\\n    this._initBody = function(body) {\\n      this._bodyInit = body\\n      if (!body) {\\n        this._bodyText = ''\\n      } else if (typeof body === 'string') {\\n        this._bodyText = body\\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\\n        this._bodyBlob = body\\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\\n        this._bodyFormData = body\\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\\n        this._bodyText = body.toString()\\n      } else if (support.arrayBuffer && support.blob && isDataView(body)) {\\n        this._bodyArrayBuffer = bufferClone(body.buffer)\\n        // IE 10-11 can't handle a DataView body.\\n        this._bodyInit = new Blob([this._bodyArrayBuffer])\\n      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\\n        this._bodyArrayBuffer = bufferClone(body)\\n      } else {\\n        throw new Error('unsupported BodyInit type')\\n      }\\n\\n      if (!this.headers.get('content-type')) {\\n        if (typeof body === 'string') {\\n          this.headers.set('content-type', 'text/plain;charset=UTF-8')\\n        } else if (this._bodyBlob && this._bodyBlob.type) {\\n          this.headers.set('content-type', this._bodyBlob.type)\\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\\n          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')\\n        }\\n      }\\n    }\\n\\n    if (support.blob) {\\n      this.blob = function() {\\n        var rejected = consumed(this)\\n        if (rejected) {\\n          return rejected\\n        }\\n\\n        if (this._bodyBlob) {\\n          return Promise.resolve(this._bodyBlob)\\n        } else if (this._bodyArrayBuffer) {\\n          return Promise.resolve(new Blob([this._bodyArrayBuffer]))\\n        } else if (this._bodyFormData) {\\n          throw new Error('could not read FormData body as blob')\\n        } else {\\n          return Promise.resolve(new Blob([this._bodyText]))\\n        }\\n      }\\n\\n      this.arrayBuffer = function() {\\n        if (this._bodyArrayBuffer) {\\n          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)\\n        } else {\\n          return this.blob().then(readBlobAsArrayBuffer)\\n        }\\n      }\\n    }\\n\\n    this.text = function() {\\n      var rejected = consumed(this)\\n      if (rejected) {\\n        return rejected\\n      }\\n\\n      if (this._bodyBlob) {\\n        return readBlobAsText(this._bodyBlob)\\n      } else if (this._bodyArrayBuffer) {\\n        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\\n      } else if (this._bodyFormData) {\\n        throw new Error('could not read FormData body as text')\\n      } else {\\n        return Promise.resolve(this._bodyText)\\n      }\\n    }\\n\\n    if (support.formData) {\\n      this.formData = function() {\\n        return this.text().then(decode)\\n      }\\n    }\\n\\n    this.json = function() {\\n      return this.text().then(JSON.parse)\\n    }\\n\\n    return this\\n  }\\n\\n  // HTTP methods whose capitalization should be normalized\\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\\n\\n  function normalizeMethod(method) {\\n    var upcased = method.toUpperCase()\\n    return (methods.indexOf(upcased) > -1) ? upcased : method\\n  }\\n\\n  function Request(input, options) {\\n    options = options || {}\\n    var body = options.body\\n\\n    if (input instanceof Request) {\\n      if (input.bodyUsed) {\\n        throw new TypeError('Already read')\\n      }\\n      this.url = input.url\\n      this.credentials = input.credentials\\n      if (!options.headers) {\\n        this.headers = new Headers(input.headers)\\n      }\\n      this.method = input.method\\n      this.mode = input.mode\\n      if (!body && input._bodyInit != null) {\\n        body = input._bodyInit\\n        input.bodyUsed = true\\n      }\\n    } else {\\n      this.url = String(input)\\n    }\\n\\n    this.credentials = options.credentials || this.credentials || 'omit'\\n    if (options.headers || !this.headers) {\\n      this.headers = new Headers(options.headers)\\n    }\\n    this.method = normalizeMethod(options.method || this.method || 'GET')\\n    this.mode = options.mode || this.mode || null\\n    this.referrer = null\\n\\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\\n      throw new TypeError('Body not allowed for GET or HEAD requests')\\n    }\\n    this._initBody(body)\\n  }\\n\\n  Request.prototype.clone = function() {\\n    return new Request(this, { body: this._bodyInit })\\n  }\\n\\n  function decode(body) {\\n    var form = new FormData()\\n    body.trim().split('&').forEach(function(bytes) {\\n      if (bytes) {\\n        var split = bytes.split('=')\\n        var name = split.shift().replace(/\\\\+/g, ' ')\\n        var value = split.join('=').replace(/\\\\+/g, ' ')\\n        form.append(decodeURIComponent(name), decodeURIComponent(value))\\n      }\\n    })\\n    return form\\n  }\\n\\n  function parseHeaders(rawHeaders) {\\n    var headers = new Headers()\\n    rawHeaders.split(/\\\\r?\\\\n/).forEach(function(line) {\\n      var parts = line.split(':')\\n      var key = parts.shift().trim()\\n      if (key) {\\n        var value = parts.join(':').trim()\\n        headers.append(key, value)\\n      }\\n    })\\n    return headers\\n  }\\n\\n  Body.call(Request.prototype)\\n\\n  function Response(bodyInit, options) {\\n    if (!options) {\\n      options = {}\\n    }\\n\\n    this.type = 'default'\\n    this.status = 'status' in options ? options.status : 200\\n    this.ok = this.status >= 200 && this.status < 300\\n    this.statusText = 'statusText' in options ? options.statusText : 'OK'\\n    this.headers = new Headers(options.headers)\\n    this.url = options.url || ''\\n    this._initBody(bodyInit)\\n  }\\n\\n  Body.call(Response.prototype)\\n\\n  Response.prototype.clone = function() {\\n    return new Response(this._bodyInit, {\\n      status: this.status,\\n      statusText: this.statusText,\\n      headers: new Headers(this.headers),\\n      url: this.url\\n    })\\n  }\\n\\n  Response.error = function() {\\n    var response = new Response(null, {status: 0, statusText: ''})\\n    response.type = 'error'\\n    return response\\n  }\\n\\n  var redirectStatuses = [301, 302, 303, 307, 308]\\n\\n  Response.redirect = function(url, status) {\\n    if (redirectStatuses.indexOf(status) === -1) {\\n      throw new RangeError('Invalid status code')\\n    }\\n\\n    return new Response(null, {status: status, headers: {location: url}})\\n  }\\n\\n  self.Headers = Headers\\n  self.Request = Request\\n  self.Response = Response\\n\\n  self.fetch = function(input, init) {\\n    return new Promise(function(resolve, reject) {\\n      var request = new Request(input, init)\\n      var xhr = new XMLHttpRequest()\\n\\n      xhr.onload = function() {\\n        var options = {\\n          status: xhr.status,\\n          statusText: xhr.statusText,\\n          headers: parseHeaders(xhr.getAllResponseHeaders() || '')\\n        }\\n        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')\\n        var body = 'response' in xhr ? xhr.response : xhr.responseText\\n        resolve(new Response(body, options))\\n      }\\n\\n      xhr.onerror = function() {\\n        reject(new TypeError('Network request failed'))\\n      }\\n\\n      xhr.ontimeout = function() {\\n        reject(new TypeError('Network request failed'))\\n      }\\n\\n      xhr.open(request.method, request.url, true)\\n\\n      if (request.credentials === 'include') {\\n        xhr.withCredentials = true\\n      }\\n\\n      if ('responseType' in xhr && support.blob) {\\n        xhr.responseType = 'blob'\\n      }\\n\\n      request.headers.forEach(function(value, name) {\\n        xhr.setRequestHeader(name, value)\\n      })\\n\\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\\n    })\\n  }\\n  self.fetch.polyfill = true\\n})(typeof self !== 'undefined' ? self : this);\\n\\n\\n//# sourceURL=webpack://%5Bname%5D_%5Bhash%5D/./node_modules/whatwg-fetch/fetch.js?\")},function(module,exports,__webpack_require__){eval(\"// the whatwg-fetch polyfill installs the fetch() function\\n// on the global object (window or self)\\n//\\n// Return that as the export for use in Webpack, Browserify etc.\\n__webpack_require__(0);\\nmodule.exports = self.fetch.bind(self);\\n\\n\\n//# sourceURL=webpack://%5Bname%5D_%5Bhash%5D/./node_modules/isomorphic-fetch/fetch-npm-browserify.js?\")},function(module,exports){eval('/** @license\\r\\n * eventsource.js\\r\\n * Available under MIT License (MIT)\\r\\n * https://github.com/Yaffle/EventSource/\\r\\n */\\r\\n\\r\\n/*jslint indent: 2, vars: true, plusplus: true */\\r\\n/*global setTimeout, clearTimeout */\\r\\n\\r\\n(function (global) {\\r\\n  \"use strict\";\\r\\n\\r\\n  var setTimeout = global.setTimeout;\\r\\n  var clearTimeout = global.clearTimeout;\\r\\n  var XMLHttpRequest = global.XMLHttpRequest;\\r\\n  var XDomainRequest = global.XDomainRequest;\\r\\n  var NativeEventSource = global.EventSource;\\r\\n  var document = global.document;\\r\\n\\r\\n  if (Object.create == null) {\\r\\n    Object.create = function (C) {\\r\\n      function F(){}\\r\\n      F.prototype = C;\\r\\n      return new F();\\r\\n    };\\r\\n  }\\r\\n\\r\\n  var k = function () {\\r\\n  };\\r\\n\\r\\n  function XHRWrapper(xhr) {\\r\\n    this.withCredentials = false;\\r\\n    this.responseType = \"\";\\r\\n    this.readyState = 0;\\r\\n    this.status = 0;\\r\\n    this.statusText = \"\";\\r\\n    this.responseText = \"\";\\r\\n    this.onprogress = k;\\r\\n    this.onreadystatechange = k;\\r\\n    this._contentType = \"\";\\r\\n    this._xhr = xhr;\\r\\n    this._sendTimeout = 0;\\r\\n    this._abort = k;\\r\\n  }\\r\\n\\r\\n  XHRWrapper.prototype.open = function (method, url) {\\r\\n    this._abort(true);\\r\\n\\r\\n    var that = this;\\r\\n    var xhr = this._xhr;\\r\\n    var state = 1;\\r\\n    var timeout = 0;\\r\\n\\r\\n    this._abort = function (silent) {\\r\\n      if (that._sendTimeout !== 0) {\\r\\n        clearTimeout(that._sendTimeout);\\r\\n        that._sendTimeout = 0;\\r\\n      }\\r\\n      if (state === 1 || state === 2 || state === 3) {\\r\\n        state = 4;\\r\\n        xhr.onload = k;\\r\\n        xhr.onerror = k;\\r\\n        xhr.onabort = k;\\r\\n        xhr.onprogress = k;\\r\\n        xhr.onreadystatechange = k;\\r\\n        // IE 8 - 9: XDomainRequest#abort() does not fire any event\\r\\n        // Opera < 10: XMLHttpRequest#abort() does not fire any event\\r\\n        xhr.abort();\\r\\n        if (timeout !== 0) {\\r\\n          clearTimeout(timeout);\\r\\n          timeout = 0;\\r\\n        }\\r\\n        if (!silent) {\\r\\n          that.readyState = 4;\\r\\n          that.onreadystatechange();\\r\\n        }\\r\\n      }\\r\\n      state = 0;\\r\\n    };\\r\\n\\r\\n    var onStart = function () {\\r\\n      if (state === 1) {\\r\\n        //state = 2;\\r\\n        var status = 0;\\r\\n        var statusText = \"\";\\r\\n        var contentType = undefined;\\r\\n        if (!(\"contentType\" in xhr)) {\\r\\n          try {\\r\\n            status = xhr.status;\\r\\n            statusText = xhr.statusText;\\r\\n            contentType = xhr.getResponseHeader(\"Content-Type\");\\r\\n          } catch (error) {\\r\\n            // IE < 10 throws exception for `xhr.status` when xhr.readyState === 2 || xhr.readyState === 3\\r\\n            // Opera < 11 throws exception for `xhr.status` when xhr.readyState === 2\\r\\n            // https://bugs.webkit.org/show_bug.cgi?id=29121\\r\\n            status = 0;\\r\\n            statusText = \"\";\\r\\n            contentType = undefined;\\r\\n            // Firefox < 14, Chrome ?, Safari ?\\r\\n            // https://bugs.webkit.org/show_bug.cgi?id=29658\\r\\n            // https://bugs.webkit.org/show_bug.cgi?id=77854\\r\\n          }\\r\\n        } else {\\r\\n          status = 200;\\r\\n          statusText = \"OK\";\\r\\n          contentType = xhr.contentType;\\r\\n        }\\r\\n        if (status !== 0) {\\r\\n          state = 2;\\r\\n          that.readyState = 2;\\r\\n          that.status = status;\\r\\n          that.statusText = statusText;\\r\\n          that._contentType = contentType;\\r\\n          that.onreadystatechange();\\r\\n        }\\r\\n      }\\r\\n    };\\r\\n    var onProgress = function () {\\r\\n      onStart();\\r\\n      if (state === 2 || state === 3) {\\r\\n        state = 3;\\r\\n        var responseText = \"\";\\r\\n        try {\\r\\n          responseText = xhr.responseText;\\r\\n        } catch (error) {\\r\\n          // IE 8 - 9 with XMLHttpRequest\\r\\n        }\\r\\n        that.readyState = 3;\\r\\n        that.responseText = responseText;\\r\\n        that.onprogress();\\r\\n      }\\r\\n    };\\r\\n    var onFinish = function () {\\r\\n      // Firefox 52 fires \"readystatechange\" (xhr.readyState === 4) without final \"readystatechange\" (xhr.readyState === 3)\\r\\n      // IE 8 fires \"onload\" without \"onprogress\"\\r\\n      onProgress();\\r\\n      if (state === 1 || state === 2 || state === 3) {\\r\\n        state = 4;\\r\\n        if (timeout !== 0) {\\r\\n          clearTimeout(timeout);\\r\\n          timeout = 0;\\r\\n        }\\r\\n        that.readyState = 4;\\r\\n        that.onreadystatechange();\\r\\n      }\\r\\n    };\\r\\n    var onReadyStateChange = function () {\\r\\n      if (xhr != undefined) { // Opera 12\\r\\n        if (xhr.readyState === 4) {\\r\\n          onFinish();\\r\\n        } else if (xhr.readyState === 3) {\\r\\n          onProgress();\\r\\n        } else if (xhr.readyState === 2) {\\r\\n          onStart();\\r\\n        }\\r\\n      }\\r\\n    };\\r\\n    var onTimeout = function () {\\r\\n      timeout = setTimeout(function () {\\r\\n        onTimeout();\\r\\n      }, 500);\\r\\n      if (xhr.readyState === 3) {\\r\\n        onProgress();\\r\\n      }\\r\\n    };\\r\\n\\r\\n    // XDomainRequest#abort removes onprogress, onerror, onload\\r\\n    xhr.onload = onFinish;\\r\\n    xhr.onerror = onFinish;\\r\\n    // improper fix to match Firefox behaviour, but it is better than just ignore abort\\r\\n    // see https://bugzilla.mozilla.org/show_bug.cgi?id=768596\\r\\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=880200\\r\\n    // https://code.google.com/p/chromium/issues/detail?id=153570\\r\\n    // IE 8 fires \"onload\" without \"onprogress\\r\\n    xhr.onabort = onFinish;\\r\\n\\r\\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=736723    \\r\\n    if (!(\"sendAsBinary\" in XMLHttpRequest.prototype) && !(\"mozAnon\" in XMLHttpRequest.prototype)) {\\r\\n      xhr.onprogress = onProgress;\\r\\n    }\\r\\n\\r\\n    // IE 8 - 9 (XMLHTTPRequest)\\r\\n    // Opera < 12\\r\\n    // Firefox < 3.5\\r\\n    // Firefox 3.5 - 3.6 - ? < 9.0\\r\\n    // onprogress is not fired sometimes or delayed\\r\\n    // see also #64\\r\\n    xhr.onreadystatechange = onReadyStateChange;\\r\\n\\r\\n    if (\"contentType\" in xhr) {\\r\\n      url += (url.indexOf(\"?\", 0) === -1 ? \"?\" : \"&\") + \"padding=true\";\\r\\n    }\\r\\n    xhr.open(method, url, true);\\r\\n\\r\\n    if (\"readyState\" in xhr) {\\r\\n      // workaround for Opera 12 issue with \"progress\" events\\r\\n      // #91\\r\\n      timeout = setTimeout(function () {\\r\\n        onTimeout();\\r\\n      }, 0);\\r\\n    }\\r\\n  };\\r\\n  XHRWrapper.prototype.abort = function () {\\r\\n    this._abort(false);\\r\\n  };\\r\\n  XHRWrapper.prototype.getResponseHeader = function (name) {\\r\\n    return this._contentType;\\r\\n  };\\r\\n  XHRWrapper.prototype.setRequestHeader = function (name, value) {\\r\\n    var xhr = this._xhr;\\r\\n    if (\"setRequestHeader\" in xhr) {\\r\\n      xhr.setRequestHeader(name, value);\\r\\n    }\\r\\n  };\\r\\n  XHRWrapper.prototype.send = function () {\\r\\n    // loading indicator in Safari < ? (6), Chrome < 14, Firefox\\r\\n    if (!(\"ontimeout\" in XMLHttpRequest.prototype) &&\\r\\n        document != undefined &&\\r\\n        document.readyState != undefined &&\\r\\n        document.readyState !== \"complete\") {\\r\\n      var that = this;\\r\\n      that._sendTimeout = setTimeout(function () {\\r\\n        that._sendTimeout = 0;\\r\\n        that.send();\\r\\n      }, 4);\\r\\n      return;\\r\\n    }\\r\\n\\r\\n    var xhr = this._xhr;\\r\\n    // withCredentials should be set after \"open\" for Safari and Chrome (< 19 ?)\\r\\n    xhr.withCredentials = this.withCredentials;\\r\\n    xhr.responseType = this.responseType;\\r\\n    try {\\r\\n      // xhr.send(); throws \"Not enough arguments\" in Firefox 3.0\\r\\n      xhr.send(undefined);\\r\\n    } catch (error1) {\\r\\n      // Safari 5.1.7, Opera 12\\r\\n      throw error1;\\r\\n    }\\r\\n  };\\r\\n\\r\\n  function XHRTransport(xhr) {\\r\\n    this._xhr = new XHRWrapper(xhr);\\r\\n  }\\r\\n\\r\\n  XHRTransport.prototype.open = function (onStartCallback, onProgressCallback, onFinishCallback, url, withCredentials, headers) {\\r\\n    var xhr = this._xhr;\\r\\n    xhr.open(\"GET\", url);\\r\\n    var offset = 0;\\r\\n    xhr.onprogress = function () {\\r\\n      var responseText = xhr.responseText;\\r\\n      var chunk = responseText.slice(offset);\\r\\n      offset += chunk.length;\\r\\n      onProgressCallback(chunk);\\r\\n    };\\r\\n    xhr.onreadystatechange = function () {\\r\\n      if (xhr.readyState === 2) {\\r\\n        var status = xhr.status;\\r\\n        var statusText = xhr.statusText;\\r\\n        var contentType = xhr.getResponseHeader(\"Content-Type\");\\r\\n        onStartCallback(status, statusText, contentType);\\r\\n      } else if (xhr.readyState === 4) {\\r\\n        onFinishCallback();\\r\\n      }\\r\\n    };\\r\\n    xhr.withCredentials = withCredentials;\\r\\n    xhr.responseType = \"text\";\\r\\n    for (var name in headers) {\\r\\n      if (Object.prototype.hasOwnProperty.call(headers, name)) {\\r\\n        xhr.setRequestHeader(name, headers[name]);\\r\\n      }\\r\\n    }\\r\\n    xhr.send();\\r\\n  };\\r\\n\\r\\n  XHRTransport.prototype.cancel = function () {\\r\\n    var xhr = this._xhr;\\r\\n    xhr.abort();\\r\\n  };\\r\\n\\r\\n  function EventTarget() {\\r\\n    this._listeners = Object.create(null);\\r\\n  }\\r\\n\\r\\n  function throwError(e) {\\r\\n    setTimeout(function () {\\r\\n      throw e;\\r\\n    }, 0);\\r\\n  }\\r\\n\\r\\n  EventTarget.prototype.dispatchEvent = function (event) {\\r\\n    event.target = this;\\r\\n    var typeListeners = this._listeners[event.type];\\r\\n    if (typeListeners != undefined) {\\r\\n      var length = typeListeners.length;\\r\\n      for (var i = 0; i < length; i += 1) {\\r\\n        var listener = typeListeners[i];\\r\\n        try {\\r\\n          if (typeof listener.handleEvent === \"function\") {\\r\\n            listener.handleEvent(event);\\r\\n          } else {\\r\\n            listener.call(this, event);\\r\\n          }\\r\\n        } catch (e) {\\r\\n          throwError(e);\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n  };\\r\\n  EventTarget.prototype.addEventListener = function (type, listener) {\\r\\n    type = String(type);\\r\\n    var listeners = this._listeners;\\r\\n    var typeListeners = listeners[type];\\r\\n    if (typeListeners == undefined) {\\r\\n      typeListeners = [];\\r\\n      listeners[type] = typeListeners;\\r\\n    }\\r\\n    var found = false;\\r\\n    for (var i = 0; i < typeListeners.length; i += 1) {\\r\\n      if (typeListeners[i] === listener) {\\r\\n        found = true;\\r\\n      }\\r\\n    }\\r\\n    if (!found) {\\r\\n      typeListeners.push(listener);\\r\\n    }\\r\\n  };\\r\\n  EventTarget.prototype.removeEventListener = function (type, listener) {\\r\\n    type = String(type);\\r\\n    var listeners = this._listeners;\\r\\n    var typeListeners = listeners[type];\\r\\n    if (typeListeners != undefined) {\\r\\n      var filtered = [];\\r\\n      for (var i = 0; i < typeListeners.length; i += 1) {\\r\\n        if (typeListeners[i] !== listener) {\\r\\n          filtered.push(typeListeners[i]);\\r\\n        }\\r\\n      }\\r\\n      if (filtered.length === 0) {\\r\\n        delete listeners[type];\\r\\n      } else {\\r\\n        listeners[type] = filtered;\\r\\n      }\\r\\n    }\\r\\n  };\\r\\n\\r\\n  function Event(type) {\\r\\n    this.type = type;\\r\\n    this.target = undefined;\\r\\n  }\\r\\n\\r\\n  function MessageEvent(type, options) {\\r\\n    Event.call(this, type);\\r\\n    this.data = options.data;\\r\\n    this.lastEventId = options.lastEventId;\\r\\n  }\\r\\n\\r\\n  MessageEvent.prototype = Object.create(Event.prototype);\\r\\n\\r\\n  var WAITING = -1;\\r\\n  var CONNECTING = 0;\\r\\n  var OPEN = 1;\\r\\n  var CLOSED = 2;\\r\\n\\r\\n  var AFTER_CR = -1;\\r\\n  var FIELD_START = 0;\\r\\n  var FIELD = 1;\\r\\n  var VALUE_START = 2;\\r\\n  var VALUE = 3;\\r\\n\\r\\n  var contentTypeRegExp = /^text\\\\/event\\\\-stream;?(\\\\s*charset\\\\=utf\\\\-8)?$/i;\\r\\n\\r\\n  var MINIMUM_DURATION = 1000;\\r\\n  var MAXIMUM_DURATION = 18000000;\\r\\n\\r\\n  var parseDuration = function (value, def) {\\r\\n    var n = parseInt(value, 10);\\r\\n    if (n !== n) {\\r\\n      n = def;\\r\\n    }\\r\\n    return clampDuration(n);\\r\\n  };\\r\\n  var clampDuration = function (n) {\\r\\n    return Math.min(Math.max(n, MINIMUM_DURATION), MAXIMUM_DURATION);\\r\\n  };\\r\\n\\r\\n  var fire = function (that, f, event) {\\r\\n    try {\\r\\n      if (typeof f === \"function\") {\\r\\n        f.call(that, event);\\r\\n      }\\r\\n    } catch (e) {\\r\\n      throwError(e);\\r\\n    }\\r\\n  };\\r\\n\\r\\n  function EventSourcePolyfill(url, options) {\\r\\n    EventTarget.call(this);\\r\\n\\r\\n    this.onopen = undefined;\\r\\n    this.onmessage = undefined;\\r\\n    this.onerror = undefined;\\r\\n\\r\\n    this.url = undefined;\\r\\n    this.readyState = undefined;\\r\\n    this.withCredentials = undefined;\\r\\n\\r\\n    this._close = undefined;\\r\\n\\r\\n    start(this, url, options);\\r\\n  }\\r\\n\\r\\n  function start(es, url, options) {\\r\\n    url = String(url);\\r\\n    var withCredentials = options != undefined && Boolean(options.withCredentials);\\r\\n\\r\\n    var initialRetry = clampDuration(1000);\\r\\n    var heartbeatTimeout = options != undefined && options.heartbeatTimeout != undefined ? parseDuration(options.heartbeatTimeout, 45000) : clampDuration(45000);\\r\\n\\r\\n    var lastEventId = \"\";\\r\\n    var retry = initialRetry;\\r\\n    var wasActivity = false;\\r\\n    var headers = options != undefined && options.headers != undefined ? JSON.parse(JSON.stringify(options.headers)) : undefined;\\r\\n    var CurrentTransport = options != undefined && options.Transport != undefined ? options.Transport : (XDomainRequest != undefined ? XDomainRequest : XMLHttpRequest);\\r\\n    var transport = new XHRTransport(new CurrentTransport());\\r\\n    var timeout = 0;\\r\\n    var currentState = WAITING;\\r\\n    var dataBuffer = \"\";\\r\\n    var lastEventIdBuffer = \"\";\\r\\n    var eventTypeBuffer = \"\";\\r\\n\\r\\n    var textBuffer = \"\";\\r\\n    var state = FIELD_START;\\r\\n    var fieldStart = 0;\\r\\n    var valueStart = 0;\\r\\n\\r\\n    var onStart = function (status, statusText, contentType) {\\r\\n      if (currentState === CONNECTING) {\\r\\n        if (status === 200 && contentType != undefined && contentTypeRegExp.test(contentType)) {\\r\\n          currentState = OPEN;\\r\\n          wasActivity = true;\\r\\n          retry = initialRetry;\\r\\n          es.readyState = OPEN;\\r\\n          var event = new Event(\"open\");\\r\\n          es.dispatchEvent(event);\\r\\n          fire(es, es.onopen, event);\\r\\n        } else {\\r\\n          var message = \"\";\\r\\n          if (status !== 200) {\\r\\n            if (statusText) {\\r\\n              statusText = statusText.replace(/\\\\s+/g, \" \");\\r\\n            }\\r\\n            message = \"EventSource\\'s response has a status \" + status + \" \" + statusText + \" that is not 200. Aborting the connection.\";\\r\\n          } else {\\r\\n            message = \"EventSource\\'s response has a Content-Type specifying an unsupported type: \" + (contentType == undefined ? \"-\" : contentType.replace(/\\\\s+/g, \" \")) + \". Aborting the connection.\";\\r\\n          }\\r\\n          throwError(new Error(message));\\r\\n          close();\\r\\n          var event = new Event(\"error\");\\r\\n          es.dispatchEvent(event);\\r\\n          fire(es, es.onerror, event);\\r\\n        }\\r\\n      }\\r\\n    };\\r\\n\\r\\n    var onProgress = function (textChunk) {\\r\\n      if (currentState === OPEN) {\\r\\n        var n = -1;\\r\\n        for (var i = 0; i < textChunk.length; i += 1) {\\r\\n          var c = textChunk.charCodeAt(i);\\r\\n          if (c === \"\\\\n\".charCodeAt(0) || c === \"\\\\r\".charCodeAt(0)) {\\r\\n            n = i;\\r\\n          }\\r\\n        }\\r\\n        var chunk = (n !== -1 ? textBuffer : \"\") + textChunk.slice(0, n + 1);\\r\\n        textBuffer = (n === -1 ? textBuffer : \"\") + textChunk.slice(n + 1);\\r\\n        if (chunk !== \"\") {\\r\\n          wasActivity = true;\\r\\n        }\\r\\n        for (var position = 0; position < chunk.length; position += 1) {\\r\\n          var c = chunk.charCodeAt(position);\\r\\n          if (state === AFTER_CR && c === \"\\\\n\".charCodeAt(0)) {\\r\\n            state = FIELD_START;\\r\\n          } else {\\r\\n            if (state === AFTER_CR) {\\r\\n              state = FIELD_START;\\r\\n            }\\r\\n            if (c === \"\\\\r\".charCodeAt(0) || c === \"\\\\n\".charCodeAt(0)) {\\r\\n              if (state !== FIELD_START) {\\r\\n                if (state === FIELD) {\\r\\n                  valueStart = position + 1;\\r\\n                }\\r\\n                var field = chunk.slice(fieldStart, valueStart - 1);\\r\\n                var value = chunk.slice(valueStart + (valueStart < position && chunk.charCodeAt(valueStart) === \" \".charCodeAt(0) ? 1 : 0), position);\\r\\n                if (field === \"data\") {\\r\\n                  dataBuffer += \"\\\\n\";\\r\\n                  dataBuffer += value;\\r\\n                } else if (field === \"id\") {\\r\\n                  lastEventIdBuffer = value;\\r\\n                } else if (field === \"event\") {\\r\\n                  eventTypeBuffer = value;\\r\\n                } else if (field === \"retry\") {\\r\\n                  initialRetry = parseDuration(value, initialRetry);\\r\\n                  retry = initialRetry;\\r\\n                } else if (field === \"heartbeatTimeout\") {\\r\\n                  heartbeatTimeout = parseDuration(value, heartbeatTimeout);\\r\\n                  if (timeout !== 0) {\\r\\n                    clearTimeout(timeout);\\r\\n                    timeout = setTimeout(function () {\\r\\n                      onTimeout();\\r\\n                    }, heartbeatTimeout);\\r\\n                  }\\r\\n                }\\r\\n              }\\r\\n              if (state === FIELD_START) {\\r\\n                if (dataBuffer !== \"\") {\\r\\n                  lastEventId = lastEventIdBuffer;\\r\\n                  if (eventTypeBuffer === \"\") {\\r\\n                    eventTypeBuffer = \"message\";\\r\\n                  }\\r\\n                  var event = new MessageEvent(eventTypeBuffer, {\\r\\n                    data: dataBuffer.slice(1),\\r\\n                    lastEventId: lastEventIdBuffer\\r\\n                  });\\r\\n                  es.dispatchEvent(event);\\r\\n                  if (eventTypeBuffer === \"message\") {\\r\\n                    fire(es, es.onmessage, event);\\r\\n                  }\\r\\n                  if (currentState === CLOSED) {\\r\\n                    return;\\r\\n                  }\\r\\n                }\\r\\n                dataBuffer = \"\";\\r\\n                eventTypeBuffer = \"\";\\r\\n              }\\r\\n              state = c === \"\\\\r\".charCodeAt(0) ? AFTER_CR : FIELD_START;\\r\\n            } else {\\r\\n              if (state === FIELD_START) {\\r\\n                fieldStart = position;\\r\\n                state = FIELD;\\r\\n              }\\r\\n              if (state === FIELD) {\\r\\n                if (c === \":\".charCodeAt(0)) {\\r\\n                  valueStart = position + 1;\\r\\n                  state = VALUE_START;\\r\\n                }\\r\\n              } else if (state === VALUE_START) {\\r\\n                state = VALUE;\\r\\n              }\\r\\n            }\\r\\n          }\\r\\n        }\\r\\n      }\\r\\n    };\\r\\n\\r\\n    var onFinish = function () {\\r\\n      if (currentState === OPEN || currentState === CONNECTING) {\\r\\n        currentState = WAITING;\\r\\n        if (timeout !== 0) {\\r\\n          clearTimeout(timeout);\\r\\n          timeout = 0;\\r\\n        }\\r\\n        timeout = setTimeout(function () {\\r\\n          onTimeout();\\r\\n        }, retry);\\r\\n        retry = clampDuration(Math.min(initialRetry * 16, retry * 2));\\r\\n\\r\\n        es.readyState = CONNECTING;\\r\\n        var event = new Event(\"error\");\\r\\n        es.dispatchEvent(event);\\r\\n        fire(es, es.onerror, event);\\r\\n      }\\r\\n    };\\r\\n\\r\\n    var close = function () {\\r\\n      currentState = CLOSED;\\r\\n      transport.cancel();\\r\\n      if (timeout !== 0) {\\r\\n        clearTimeout(timeout);\\r\\n        timeout = 0;\\r\\n      }\\r\\n      es.readyState = CLOSED;\\r\\n    };\\r\\n\\r\\n    var onTimeout = function () {\\r\\n      timeout = 0;\\r\\n\\r\\n      if (currentState !== WAITING) {\\r\\n        if (!wasActivity) {\\r\\n          throwError(new Error(\"No activity within \" + heartbeatTimeout + \" milliseconds. Reconnecting.\"));\\r\\n          transport.cancel();\\r\\n        } else {\\r\\n          wasActivity = false;\\r\\n          timeout = setTimeout(function () {\\r\\n            onTimeout();\\r\\n          }, heartbeatTimeout);\\r\\n        }\\r\\n        return;\\r\\n      }\\r\\n\\r\\n      wasActivity = false;\\r\\n      timeout = setTimeout(function () {\\r\\n        onTimeout();\\r\\n      }, heartbeatTimeout);\\r\\n\\r\\n      currentState = CONNECTING;\\r\\n      dataBuffer = \"\";\\r\\n      eventTypeBuffer = \"\";\\r\\n      lastEventIdBuffer = lastEventId;\\r\\n      textBuffer = \"\";\\r\\n      fieldStart = 0;\\r\\n      valueStart = 0;\\r\\n      state = FIELD_START;\\r\\n\\r\\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=428916\\r\\n      // Request header field Last-Event-ID is not allowed by Access-Control-Allow-Headers.\\r\\n      var requestURL = url;\\r\\n      if (url.slice(0, 5) !== \"data:\" &&\\r\\n          url.slice(0, 5) !== \"blob:\") {\\r\\n        requestURL = url + (url.indexOf(\"?\", 0) === -1 ? \"?\" : \"&\") + \"lastEventId=\" + encodeURIComponent(lastEventId);\\r\\n      }\\r\\n      var requestHeaders = {};\\r\\n      requestHeaders[\"Accept\"] = \"text/event-stream\";\\r\\n      if (headers != undefined) {\\r\\n        for (var name in headers) {\\r\\n          if (Object.prototype.hasOwnProperty.call(headers, name)) {\\r\\n            requestHeaders[name] = headers[name];\\r\\n          }\\r\\n        }\\r\\n      }\\r\\n      try {\\r\\n        transport.open(onStart, onProgress, onFinish, requestURL, withCredentials, requestHeaders);\\r\\n      } catch (error) {\\r\\n        close();\\r\\n        throw error;\\r\\n      }\\r\\n    };\\r\\n\\r\\n    es.url = url;\\r\\n    es.readyState = CONNECTING;\\r\\n    es.withCredentials = withCredentials;\\r\\n    es._close = close;\\r\\n\\r\\n    onTimeout();\\r\\n  }\\r\\n\\r\\n  EventSourcePolyfill.prototype = Object.create(EventTarget.prototype);\\r\\n  EventSourcePolyfill.prototype.CONNECTING = CONNECTING;\\r\\n  EventSourcePolyfill.prototype.OPEN = OPEN;\\r\\n  EventSourcePolyfill.prototype.CLOSED = CLOSED;\\r\\n  EventSourcePolyfill.prototype.close = function () {\\r\\n    this._close();\\r\\n  };\\r\\n\\r\\n  EventSourcePolyfill.CONNECTING = CONNECTING;\\r\\n  EventSourcePolyfill.OPEN = OPEN;\\r\\n  EventSourcePolyfill.CLOSED = CLOSED;\\r\\n  EventSourcePolyfill.prototype.withCredentials = undefined;\\r\\n\\r\\n  global.EventSourcePolyfill = EventSourcePolyfill;\\r\\n  global.NativeEventSource = NativeEventSource;\\r\\n\\r\\n  if (XMLHttpRequest != undefined && (NativeEventSource == undefined || !(\"withCredentials\" in NativeEventSource.prototype))) {\\r\\n    // Why replace a native EventSource ?\\r\\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=444328\\r\\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=831392\\r\\n    // https://code.google.com/p/chromium/issues/detail?id=260144\\r\\n    // https://code.google.com/p/chromium/issues/detail?id=225654\\r\\n    // ...\\r\\n    global.EventSource = EventSourcePolyfill;\\r\\n  }\\r\\n\\r\\n}(typeof window !== \\'undefined\\' ? window : this));\\r\\n\\n\\n//# sourceURL=webpack://%5Bname%5D_%5Bhash%5D/./node_modules/event-source-polyfill/src/eventsource.js?')},function(module,exports,__webpack_require__){eval(\"module.exports = __webpack_require__;\\n\\n//# sourceURL=webpack://%5Bname%5D_%5Bhash%5D/dll_vendor?\")}]);","extractedComments":[]}